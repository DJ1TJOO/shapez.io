<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: savegame/serialization_data_types.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: savegame/serialization_data_types.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* typehints:start */
import { GameRoot } from "../game/root";
import { BasicSerializableObject } from "./serialization";
/* typehints:end */

import { Vector } from "../core/vector";
import { round4Digits } from "../core/utils";
export const globalJsonSchemaDefs = {};

/**
 *
 * @param {import("./serialization").Schema} schema
 */
export function schemaToJsonSchema(schema) {
    const jsonSchema = {
        type: "object",
        additionalProperties: false,
        required: [],
        properties: {},
    };

    for (const key in schema) {
        const subSchema = schema[key].getAsJsonSchema();
        jsonSchema.required.push(key);
        jsonSchema.properties[key] = subSchema;
    }

    return jsonSchema;
}

/**
 * Helper function to create a json schema object
 * @param {any} properties
 */
function schemaObject(properties) {
    return {
        type: "object",
        required: Object.keys(properties).slice(),
        additionalProperties: false,
        properties,
    };
}

/**
 * Base serialization data type
 */
export class BaseDataType {
    /**
     * Serializes a given raw value
     * @param {any} value
     */
    serialize(value) {
        abstract;
        return {};
    }

    /**
     * Verifies a given serialized value
     * @param {any} value
     * @returns {string|void} String error code or null on success
     */
    verifySerializedValue(value) {}

    /**
     * Deserializes a serialized value into the target object under the given key
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        abstract;
    }

    /**
     * Returns the json schema
     */
    getAsJsonSchema() {
        const key = this.getCacheKey();
        const schema = this.getAsJsonSchemaUncached();

        if (!globalJsonSchemaDefs[key]) {
            // schema.$id = key;
            globalJsonSchemaDefs[key] = schema;
        }

        return {
            $ref: "#/definitions/" + key,
        };
    }

    /**
     * INTERNAL Should return the json schema representation
     */
    getAsJsonSchemaUncached() {
        abstract;
    }

    /**
     * Returns whether null values are okay
     * @returns {boolean}
     */
    allowNull() {
        return false;
    }

    // Helper methods

    /**
     * Deserializes a serialized value, but performs integrity checks before
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserializeWithVerify(value, targetObject, targetKey, root) {
        const errorCode = this.verifySerializedValue(value);
        if (errorCode) {
            return (
                "serialization verify failed: " +
                errorCode +
                " [value " +
                (JSON.stringify(value) || "").substr(0, 100) +
                "]"
            );
        }
        return this.deserialize(value, targetObject, targetKey, root);
    }

    /**
     * Should return a cacheable key
     */
    getCacheKey() {
        abstract;
        return "";
    }
}

export class TypeInteger extends BaseDataType {
    serialize(value) {
        assert(Number.isInteger(value), "Type integer got non integer for serialize: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "integer",
        };
    }

    verifySerializedValue(value) {
        if (!Number.isInteger(value)) {
            return "Not a valid number";
        }
    }

    getCacheKey() {
        return "int";
    }
}

export class TypePositiveInteger extends BaseDataType {
    serialize(value) {
        assert(Number.isInteger(value), "Type integer got non integer for serialize: " + value);
        assert(value >= 0, "value &lt; 0: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "integer",
            minimum: 0,
        };
    }

    verifySerializedValue(value) {
        if (!Number.isInteger(value)) {
            return "Not a valid number";
        }
        if (value &lt; 0) {
            return "Negative value for positive integer";
        }
    }

    getCacheKey() {
        return "uint";
    }
}

export class TypeBoolean extends BaseDataType {
    serialize(value) {
        assert(value === true || value === false, "Type bool got non bool for serialize: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "boolean",
        };
    }

    verifySerializedValue(value) {
        if (value !== true &amp;&amp; value !== false) {
            return "Not a boolean";
        }
    }

    getCacheKey() {
        return "bool";
    }
}

export class TypeString extends BaseDataType {
    serialize(value) {
        assert(typeof value === "string", "Type string got non string for serialize: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }
    getAsJsonSchemaUncached() {
        return {
            type: "string",
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "string") {
            return "Not a valid string";
        }
    }

    getCacheKey() {
        return "string";
    }
}

export class TypeVector extends BaseDataType {
    serialize(value) {
        assert(value instanceof Vector, "Type vector got non vector for serialize: " + value);
        return {
            x: round4Digits(value.x),
            y: round4Digits(value.y),
        };
    }

    getAsJsonSchemaUncached() {
        return schemaObject({
            x: {
                type: "number",
            },
            y: {
                type: "number",
            },
        });
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = new Vector(value.x, value.y);
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value.x) || !Number.isFinite(value.y)) {
            return "Not a valid vector, missing x/y or bad data type";
        }
    }

    getCacheKey() {
        return "vector";
    }
}

export class TypeTileVector extends BaseDataType {
    serialize(value) {
        assert(value instanceof Vector, "Type vector got non vector for serialize: " + value);
        assert(Number.isInteger(value.x) &amp;&amp; value.x > 0, "Invalid tile x:" + value.x);
        assert(Number.isInteger(value.y) &amp;&amp; value.y > 0, "Invalid tile x:" + value.y);
        return { x: value.x, y: value.y };
    }

    getAsJsonSchemaUncached() {
        return schemaObject({
            x: {
                type: "integer",
                minimum: 0,
                maximum: 256,
            },
            y: {
                type: "integer",
                minimum: 0,
                maximum: 256,
            },
        });
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = new Vector(value.x, value.y);
    }

    verifySerializedValue(value) {
        if (!Number.isInteger(value.x) || !Number.isInteger(value.y)) {
            return "Not a valid tile vector, missing x/y or bad data type";
        }
        if (value.x &lt; 0 || value.y &lt; 0) {
            return "Invalid tile vector, x or y &lt; 0";
        }
    }

    getCacheKey() {
        return "tilevector";
    }
}

export class TypeNumber extends BaseDataType {
    serialize(value) {
        assert(Number.isFinite(value), "Type number got non number for serialize: " + value);
        assert(!Number.isNaN(value), "Value is nan: " + value);
        return round4Digits(value);
    }

    getAsJsonSchemaUncached() {
        return {
            type: "number",
        };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value)) {
            return "Not a valid number: " + value;
        }
    }

    getCacheKey() {
        return "float";
    }
}

export class TypePositiveNumber extends BaseDataType {
    serialize(value) {
        assert(Number.isFinite(value), "Type number got non number for serialize: " + value);
        assert(value >= 0, "Postitive number got negative value: " + value);
        return round4Digits(value);
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "number",
            minimum: 0,
        };
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value)) {
            return "Not a valid number: " + value;
        }
        if (value &lt; 0) {
            return "Positive number got negative value: " + value;
        }
    }

    getCacheKey() {
        return "ufloat";
    }
}

export class TypeEnum extends BaseDataType {
    /**
     * @param {Object.&lt;string, any>} enumeration
     */
    constructor(enumeration = {}) {
        super();
        this.availableValues = Object.values(enumeration);
    }

    serialize(value) {
        assert(this.availableValues.indexOf(value) >= 0, "Unknown value: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "string",
            enum: this.availableValues,
        };
    }

    verifySerializedValue(value) {
        if (this.availableValues.indexOf(value) &lt; 0) {
            return "Unknown enum value: " + value;
        }
    }

    getCacheKey() {
        return "enum." + this.availableValues.join(",");
    }
}

export class TypeEntity extends BaseDataType {
    serialize(value) {
        // assert(value instanceof Entity, "Not a valid entity ref: " + value);
        assert(value.uid, "Entity has no uid yet");
        assert(!value.destroyed, "Entity already destroyed");
        assert(!value.queuedForDestroy, "Entity queued for destroy");

        return value.uid;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "integer",
            minimum: 0,
        };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const entity = root.entityMgr.findByUid(value);
        if (!entity) {
            return "Entity not found by uid: " + value;
        }
        targetObject[targetKey] = entity;
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value)) {
            return "Not a valid uuid: " + value;
        }
    }

    getCacheKey() {
        return "entity";
    }
}

export class TypeEntityWeakref extends BaseDataType {
    serialize(value) {
        if (value === null) {
            return null;
        }

        // assert(value instanceof Entity, "Not a valid entity ref (weak): " + value);
        assert(value.uid, "Entity has no uid yet");
        if (value.destroyed || value.queuedForDestroy) {
            return null;
        }
        return value.uid;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        if (value === null) {
            targetObject[targetKey] = null;
            return;
        }
        const entity = root.entityMgr.findByUid(value, false);
        targetObject[targetKey] = entity;
    }

    getAsJsonSchemaUncached() {
        return {
            type: ["null", "integer"],
            minimum: 0,
        };
    }

    allowNull() {
        return true;
    }

    verifySerializedValue(value) {
        if (value !== null &amp;&amp; !Number.isFinite(value)) {
            return "Not a valid uuid: " + value;
        }
    }

    getCacheKey() {
        return "entity-weakref";
    }
}

export class TypeClass extends BaseDataType {
    /**
     *
     * @param {FactoryTemplate&lt;*>} registry
     * @param {(GameRoot, object) => object} customResolver
     */
    constructor(registry, customResolver = null) {
        super();
        this.registry = registry;
        this.customResolver = customResolver;
    }

    serialize(value) {
        assert(typeof value === "object", "Not a class instance: " + value);
        return {
            $: value.constructor.getId(),
            data: value.serialize(),
        };
    }

    getAsJsonSchemaUncached() {
        const options = [];
        const entries = this.registry.getEntries();
        for (let i = 0; i &lt; entries.length; ++i) {
            const entry = entries[i];

            options.push(
                schemaObject({
                    $: {
                        type: "string",
                        // @ts-ignore
                        enum: [entry.getId()],
                    },
                    // @ts-ignore
                    data: schemaToJsonSchema(entry.getCachedSchema()),
                })
            );
        }

        return { oneOf: options };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        let instance;

        if (this.customResolver) {
            instance = this.customResolver(root, value);
            if (!instance) {
                return "Failed to call custom resolver";
            }
        } else {
            const instanceClass = this.registry.findById(value.$);
            if (!instanceClass || !instanceClass.prototype) {
                return "Invalid class id (runtime-err): " + value.$ + "->" + instanceClass;
            }
            instance = Object.create(instanceClass.prototype);
            const errorState = instance.deserialize(value.data);
            if (errorState) {
                return errorState;
            }
        }
        targetObject[targetKey] = instance;
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }

        if (!this.registry.hasId(value.$)) {
            return "Invalid class id: " + value.$ + " (factory is " + this.registry.getId() + ")";
        }
    }

    getCacheKey() {
        return "class." + this.registry.getId();
    }
}

export class TypeClassData extends BaseDataType {
    /**
     *
     * @param {FactoryTemplate&lt;*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        assert(typeof value === "object", "Not a class instance: " + value);
        return value.serialize();
    }

    getAsJsonSchemaUncached() {
        const options = [];
        const entries = this.registry.getEntries();
        for (let i = 0; i &lt; entries.length; ++i) {
            const entry = entries[i];
            options.push(
                schemaToJsonSchema(/** @type {typeof BasicSerializableObject} */ (entry).getCachedSchema())
            );
        }
        return { oneOf: options };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        assert(false, "can not deserialize class data of type " + this.registry.getId());
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }
    }

    getCacheKey() {
        return "class." + this.registry.getId();
    }
}

export class TypeClassFromMetaclass extends BaseDataType {
    /**
     *
     * @param {typeof BasicSerializableObject} classHandle
     * @param {SingletonFactoryTemplate&lt;*>} registry
     */
    constructor(classHandle, registry) {
        super();
        this.registry = registry;
        this.classHandle = classHandle;
    }

    serialize(value) {
        assert(typeof value === "object", "Not a class instance: " + value);
        return {
            $: value.getMetaclass().getId(),
            data: value.serialize(),
        };
    }

    getAsJsonSchemaUncached() {
        // const options = [];
        const ids = this.registry.getAllIds();

        return {
            $: {
                type: "string",
                enum: ids,
            },
            data: schemaToJsonSchema(this.classHandle.getCachedSchema()),
        };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const metaClassInstance = this.registry.findById(value.$);
        if (!metaClassInstance || !metaClassInstance.prototype) {
            return "Invalid meta class id (runtime-err): " + value.$ + "->" + metaClassInstance;
        }

        const instanceClass = metaClassInstance.getInstanceClass();
        const instance = Object.create(instanceClass.prototype);
        const errorState = instance.deserialize(value.data);
        if (errorState) {
            return errorState;
        }
        targetObject[targetKey] = instance;
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }

        if (!this.registry.hasId(value.$)) {
            return "Invalid class id: " + value.$ + " (factory is " + this.registry.getId() + ")";
        }
    }

    getCacheKey() {
        return "classofmetaclass." + this.registry.getId();
    }
}

export class TypeMetaClass extends BaseDataType {
    /**
     *
     * @param {SingletonFactoryTemplate&lt;*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        return value.getId();
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const instanceClass = this.registry.findById(value);
        if (!instanceClass) {
            return "Invalid class id (runtime-err): " + value;
        }
        targetObject[targetKey] = instanceClass;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "string",
            enum: this.registry.getAllIds(),
        };
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }

        if (typeof value !== "string") {
            return "Got non string data";
        }

        if (!this.registry.hasId(value)) {
            return "Invalid class id: " + value + " (factory is " + this.registry.getId() + ")";
        }
    }

    getCacheKey() {
        return "metaclass." + this.registry.getId();
    }
}

export class TypeArray extends BaseDataType {
    /**
     * @param {BaseDataType} innerType
     */
    constructor(innerType, fixedSize = false) {
        super();
        this.fixedSize = fixedSize;
        this.innerType = innerType;
    }

    serialize(value) {
        assert(Array.isArray(value), "Not an array");
        const result = new Array(value.length);
        for (let i = 0; i &lt; value.length; ++i) {
            result[i] = this.innerType.serialize(value[i]);
        }
        return result;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        let destination = targetObject[targetKey];
        if (!destination) {
            targetObject[targetKey] = destination = new Array(value.length);
        }

        const size = this.fixedSize ? Math.min(value.length, destination.length) : value.length;

        for (let i = 0; i &lt; size; ++i) {
            const errorStatus = this.innerType.deserializeWithVerify(value[i], destination, i, root);
            if (errorStatus) {
                return errorStatus;
            }
        }
    }

    getAsJsonSchemaUncached() {
        return {
            type: "array",
            items: this.innerType.getAsJsonSchema(),
        };
    }

    verifySerializedValue(value) {
        if (!Array.isArray(value)) {
            return "Not an array: " + value;
        }
    }

    getCacheKey() {
        return "array." + this.innerType.getCacheKey();
    }
}

export class TypeFixedClass extends BaseDataType {
    /**
     *
     * @param {typeof BasicSerializableObject} baseclass
     */
    constructor(baseclass) {
        super();
        this.baseclass = baseclass;
    }

    serialize(value) {
        assert(value instanceof this.baseclass, "Not a valid class instance");
        return value.serialize();
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const instance = Object.create(this.baseclass.prototype);
        const errorState = instance.deserialize(value);
        if (errorState) {
            return "Failed to deserialize class: " + errorState;
        }
        targetObject[targetKey] = instance;
    }

    getAsJsonSchemaUncached() {
        this.baseclass.getSchema();
        this.baseclass.getCachedSchema();
        return schemaToJsonSchema(this.baseclass.getCachedSchema());
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }
    }

    getCacheKey() {
        return "fixedclass." + this.baseclass.getId();
    }
}

export class TypeKeyValueMap extends BaseDataType {
    /**
     * @param {BaseDataType} valueType
     * @param {boolean=} includeEmptyValues
     */
    constructor(valueType, includeEmptyValues = true) {
        super();
        this.valueType = valueType;
        this.includeEmptyValues = includeEmptyValues;
    }

    serialize(value) {
        assert(typeof value === "object", "not an object");
        let result = {};
        for (const key in value) {
            const serialized = this.valueType.serialize(value[key]);
            if (!this.includeEmptyValues &amp;&amp; typeof serialized === "object") {
                if (
                    serialized.$ &amp;&amp;
                    typeof serialized.data === "object" &amp;&amp;
                    Object.keys(serialized.data).length === 0
                ) {
                    continue;
                } else if (Object.keys(serialized).length === 0) {
                    continue;
                }
            }

            result[key] = serialized;
        }
        return result;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        let result = {};
        for (const key in value) {
            const errorCode = this.valueType.deserializeWithVerify(value[key], result, key, root);
            if (errorCode) {
                return errorCode;
            }
        }
        targetObject[targetKey] = result;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "object",
            additionalProperties: this.valueType.getAsJsonSchema(),
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "object") {
            return "KV map is not an object";
        }
    }

    getCacheKey() {
        return "kvmap." + this.valueType.getCacheKey();
    }
}

export class TypeClassId extends BaseDataType {
    /**
     * @param {FactoryTemplate&lt;*>|SingletonFactoryTemplate&lt;*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        assert(typeof value === "string", "Not a valid string");
        assert(this.registry.hasId(value), "Id " + value + " not found in registry");
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "string",
            enum: this.registry.getAllIds(),
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "string") {
            return "Not a valid registry id key: " + value;
        }
        if (!this.registry.hasId(value)) {
            return "Id " + value + " not known to registry";
        }
    }

    getCacheKey() {
        return "classid." + this.registry.getId();
    }
}

export class TypePair extends BaseDataType {
    /**
     * @param {BaseDataType} type1
     * @param {BaseDataType} type2
     */
    constructor(type1, type2) {
        super();
        assert(type1 &amp;&amp; type1 instanceof BaseDataType, "bad first type given for pair");
        assert(type2 &amp;&amp; type2 instanceof BaseDataType, "bad second type given for pair");
        this.type1 = type1;
        this.type2 = type2;
    }

    serialize(value) {
        assert(Array.isArray(value), "pair: not an array");
        assert(value.length === 2, "pair: length != 2");
        return [this.type1.serialize(value[0]), this.type2.serialize(value[1])];
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const result = [undefined, undefined];

        let errorCode = this.type1.deserialize(value[0], result, 0, root);
        if (errorCode) {
            return errorCode;
        }
        errorCode = this.type2.deserialize(value[1], result, 1, root);
        if (errorCode) {
            return errorCode;
        }

        targetObject[targetKey] = result;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "array",
            minLength: 2,
            maxLength: 2,
            items: [this.type1.getAsJsonSchema(), this.type2.getAsJsonSchema()],
        };
    }

    verifySerializedValue(value) {
        if (!Array.isArray(value)) {
            return "Pair is not an array";
        }
        if (value.length !== 2) {
            return "Pair length != 2";
        }
        let errorCode = this.type1.verifySerializedValue(value[0]);
        if (errorCode) {
            return errorCode;
        }
        errorCode = this.type2.verifySerializedValue(value[1]);
        if (errorCode) {
            return errorCode;
        }
    }

    getCacheKey() {
        return "pair.(" + this.type1.getCacheKey() + "," + this.type2.getCacheKey + ")";
    }
}

export class TypeNullable extends BaseDataType {
    /**
     * @param {BaseDataType} wrapped
     */
    constructor(wrapped) {
        super();
        this.wrapped = wrapped;
    }

    serialize(value) {
        if (value === null || value === undefined) {
            return null;
        }
        return this.wrapped.serialize(value);
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        if (value === null || value === undefined) {
            targetObject[targetKey] = null;
            return;
        }
        return this.wrapped.deserialize(value, targetObject, targetKey, root);
    }

    verifySerializedValue(value) {
        if (value === null) {
            return;
        }
        return this.wrapped.verifySerializedValue(value);
    }

    getAsJsonSchemaUncached() {
        return {
            oneOf: [
                {
                    type: "null",
                },
                this.wrapped.getAsJsonSchema(),
            ],
        };
    }

    allowNull() {
        return true;
    }

    getCacheKey() {
        return "nullable." + this.wrapped.getCacheKey();
    }
}

export class TypeStructuredObject extends BaseDataType {
    /**
     * @param {Object.&lt;string, BaseDataType>} descriptor
     */
    constructor(descriptor) {
        super();
        this.descriptor = descriptor;
    }

    serialize(value) {
        assert(typeof value === "object", "not an object");
        let result = {};
        for (const key in this.descriptor) {
            // assert(value.hasOwnProperty(key), "Serialization: Object does not have", key, "property!");
            result[key] = this.descriptor[key].serialize(value[key]);
        }
        return result;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        let target = targetObject[targetKey];
        if (!target) {
            targetObject[targetKey] = target = {};
        }

        for (const key in value) {
            const valueType = this.descriptor[key];
            const errorCode = valueType.deserializeWithVerify(value[key], target, key, root);
            if (errorCode) {
                return errorCode;
            }
        }
    }

    getAsJsonSchemaUncached() {
        let properties = {};
        for (const key in this.descriptor) {
            properties[key] = this.descriptor[key].getAsJsonSchema();
        }

        return {
            type: "object",
            required: Object.keys(this.descriptor),
            properties,
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "object") {
            return "structured object is not an object";
        }
        for (const key in this.descriptor) {
            if (!value.hasOwnProperty(key)) {
                return "structured object is missing key " + key;
            }
            const subError = this.descriptor[key].verifySerializedValue(value[key]);
            if (subError) {
                return "structured object::" + subError;
            }
        }
    }

    getCacheKey() {
        let props = [];
        for (const key in this.descriptor) {
            props.push(key + "=" + this.descriptor[key].getCacheKey());
        }
        return "structured[" + props.join(",") + "]";
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AdinplayAdProvider_AdinplayAdProvider.html">AdinplayAdProvider</a></li><li><a href="AdProviderInterface_AdProviderInterface.html">AdProviderInterface</a></li><li><a href="AtlasDefinition_AtlasDefinition.html">AtlasDefinition</a></li><li><a href="AtlasSprite_AtlasSprite.html">AtlasSprite</a></li><li><a href="BackgroundResourcesLoader_BackgroundResourcesLoader.html">BackgroundResourcesLoader</a></li><li><a href="BaseDataType.html">BaseDataType</a></li><li><a href="BaseGameSpeed_BaseGameSpeed.html">BaseGameSpeed</a></li><li><a href="BaseHUDPart_BaseHUDPart.html">BaseHUDPart</a></li><li><a href="BaseItem.html">BaseItem</a></li><li><a href="BaseMap_BaseMap.html">BaseMap</a></li><li><a href="BaseSavegameInterface_BaseSavegameInterface.html">BaseSavegameInterface</a></li><li><a href="BaseSetting_BaseSetting.html">BaseSetting</a></li><li><a href="BasicSerializableObject_BasicSerializableObject.html">BasicSerializableObject</a></li><li><a href="BeltComponent_BeltComponent.html">BeltComponent</a></li><li><a href="BeltPath.html">BeltPath</a></li><li><a href="BeltSystem.html">BeltSystem</a></li><li><a href="Blueprint_Blueprint.html">Blueprint</a></li><li><a href="BooleanItem_BooleanItem.html">BooleanItem</a></li><li><a href="BufferMaintainer_BufferMaintainer.html">BufferMaintainer</a></li><li><a href="ColorItem_ColorItem.html">ColorItem</a></li><li><a href="Component_Component.html">Component</a></li><li><a href="ConstantSignalComponent_ConstantSignalComponent.html">ConstantSignalComponent</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="DialogLoading.html">DialogLoading</a></li><li><a href="DialogWithForm_DialogWithForm.html">DialogWithForm</a></li><li><a href="DynamicDomAttach_DynamicDomAttach.html">DynamicDomAttach</a></li><li><a href="DynamicTickrate_DynamicTickrate.html">DynamicTickrate</a></li><li><a href="Entity_Entity.html">Entity</a></li><li><a href="EntityComponentStorage.html">EntityComponentStorage</a></li><li><a href="FormElementItemChooser_FormElementItemChooser.html">FormElementItemChooser</a></li><li><a href="GameCore.html">GameCore</a></li><li><a href="GamedistributionAdProvider_GamedistributionAdProvider.html">GamedistributionAdProvider</a></li><li><a href="GameHUD_GameHUD.html">GameHUD</a></li><li><a href="GameLoadingOverlay_GameLoadingOverlay.html">GameLoadingOverlay</a></li><li><a href="GameLogic_GameLogic.html">GameLogic</a></li><li><a href="GameRoot.html">GameRoot</a></li><li><a href="GameState.html">GameState</a></li><li><a href="GameSystem.html">GameSystem</a></li><li><a href="GameSystemManager_GameSystemManager.html">GameSystemManager</a></li><li><a href="GameSystemWithFilter_GameSystemWithFilter.html">GameSystemWithFilter</a></li><li><a href="GameTime_GameTime.html">GameTime</a></li><li><a href="HubGoals_HubGoals.html">HubGoals</a></li><li><a href="HUDBaseToolbar_HUDBaseToolbar.html">HUDBaseToolbar</a></li><li><a href="HUDBuildingPlacerLogic.html">HUDBuildingPlacerLogic</a></li><li><a href="HUDEntityDebugger.html">HUDEntityDebugger</a></li><li><a href="HUDLayerPreview.html">HUDLayerPreview</a></li><li><a href="HUDPinnedShapes.html">HUDPinnedShapes</a></li><li><a href="HUDShapeStatisticsHandle.html">HUDShapeStatisticsHandle</a></li><li><a href="HUDTutorialVideoOffer.html">HUDTutorialVideoOffer</a></li><li><a href="InputDistributor_InputDistributor.html">InputDistributor</a></li><li><a href="KeyActionMapper_KeyActionMapper.html">KeyActionMapper</a></li><li><a href="Keybinding_Keybinding.html">Keybinding</a></li><li><a href="LeverComponent_LeverComponent.html">LeverComponent</a></li><li><a href="Logger.html">Logger</a></li><li><a href="LogicGateComponent_LogicGateComponent.html">LogicGateComponent</a></li><li><a href="MapChunk_MapChunk.html">MapChunk</a></li><li><a href="MapChunkView_MapChunkView.html">MapChunkView</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MetaBuilding_MetaBuilding.html">MetaBuilding</a></li><li><a href="ProductionAnalytics_ProductionAnalytics.html">ProductionAnalytics</a></li><li><a href="RandomNumberGenerator_RandomNumberGenerator.html">RandomNumberGenerator</a></li><li><a href="RestrictionManager_RestrictionManager.html">RestrictionManager</a></li><li><a href="SavegameSerializer.html">SavegameSerializer</a></li><li><a href="ShapeDefinition_ShapeDefinition.html">ShapeDefinition</a></li><li><a href="ShapeDefinitionManager_ShapeDefinitionManager.html">ShapeDefinitionManager</a></li><li><a href="ShapeItem_ShapeItem.html">ShapeItem</a></li><li><a href="SoundProxy_SoundProxy.html">SoundProxy</a></li><li><a href="SpriteAtlasLink.html">SpriteAtlasLink</a></li><li><a href="StaleAreaDetector_StaleAreaDetector.html">StaleAreaDetector</a></li><li><a href="StateManager.html">StateManager</a></li><li><a href="StaticMapEntityComponent_StaticMapEntityComponent.html">StaticMapEntityComponent</a></li><li><a href="StorageComponent_StorageComponent.html">StorageComponent</a></li><li><a href="TextualGameState.html">TextualGameState</a></li><li><a href="TrailerMaker_TrailerMaker.html">TrailerMaker</a></li><li><a href="TypeArray_TypeArray.html">TypeArray</a></li><li><a href="TypeClass_TypeClass.html">TypeClass</a></li><li><a href="TypeClassData_TypeClassData.html">TypeClassData</a></li><li><a href="TypeClassFromMetaclass_TypeClassFromMetaclass.html">TypeClassFromMetaclass</a></li><li><a href="TypeClassId_TypeClassId.html">TypeClassId</a></li><li><a href="TypeEnum_TypeEnum.html">TypeEnum</a></li><li><a href="TypeFixedClass_TypeFixedClass.html">TypeFixedClass</a></li><li><a href="TypeKeyValueMap_TypeKeyValueMap.html">TypeKeyValueMap</a></li><li><a href="TypeMetaClass_TypeMetaClass.html">TypeMetaClass</a></li><li><a href="TypeNullable_TypeNullable.html">TypeNullable</a></li><li><a href="TypePair_TypePair.html">TypePair</a></li><li><a href="TypeStructuredObject_TypeStructuredObject.html">TypeStructuredObject</a></li><li><a href="UndergroundBeltComponent_UndergroundBeltComponent.html">UndergroundBeltComponent</a></li><li><a href="Vector_Vector.html">Vector</a></li><li><a href="WireComponent_WireComponent.html">WireComponent</a></li><li><a href="WrappedSoundInstance.html">WrappedSoundInstance</a></li></ul><h3>Global</h3><ul><li><a href="global.html#accessNestedPropertyReverse">accessNestedPropertyReverse</a></li><li><a href="global.html#allApplicationSettings">allApplicationSettings</a></li><li><a href="global.html#arrayAllDirections">arrayAllDirections</a></li><li><a href="global.html#arrayDelete">arrayDelete</a></li><li><a href="global.html#arrayDeleteValue">arrayDeleteValue</a></li><li><a href="global.html#arrayUndergroundRotationVariantToMode">arrayUndergroundRotationVariantToMode</a></li><li><a href="global.html#atlasFiles">atlasFiles</a></li><li><a href="global.html#autoDetectLanguageId">autoDetectLanguageId</a></li><li><a href="global.html#buildBuildingCodeCache">buildBuildingCodeCache</a></li><li><a href="global.html#cachebust">cachebust</a></li><li><a href="global.html#capitalizeFirstLetter">capitalizeFirstLetter</a></li><li><a href="global.html#catchErrors">catchErrors</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clearBufferBacklog">clearBufferBacklog</a></li><li><a href="global.html#COLOR_ITEM_SINGLETONS">COLOR_ITEM_SINGLETONS</a></li><li><a href="global.html#compressInt">compressInt</a></li><li><a href="global.html#compressObject">compressObject</a></li><li><a href="global.html#compressObjectInternal">compressObjectInternal</a></li><li><a href="global.html#compressU8WHeader">compressU8WHeader</a></li><li><a href="global.html#computeCrc">computeCrc</a></li><li><a href="global.html#createSimpleShape">createSimpleShape</a></li><li><a href="global.html#decompressInt">decompressInt</a></li><li><a href="global.html#decompressObject">decompressObject</a></li><li><a href="global.html#decompressObjectInternal">decompressObjectInternal</a></li><li><a href="global.html#decompressU8WHeader">decompressU8WHeader</a></li><li><a href="global.html#deserializeSchema">deserializeSchema</a></li><li><a href="global.html#disableImageSmoothing">disableImageSmoothing</a></li><li><a href="global.html#drawRotatedSprite">drawRotatedSprite</a></li><li><a href="global.html#drawSpriteClipped">drawSpriteClipped</a></li><li><a href="global.html#enableImageSmoothing">enableImageSmoothing</a></li><li><a href="global.html#enumAnalyticsDataSource">enumAnalyticsDataSource</a></li><li><a href="global.html#enumAngleToDirection">enumAngleToDirection</a></li><li><a href="global.html#enumBalancerVariants">enumBalancerVariants</a></li><li><a href="global.html#enumCategories">enumCategories</a></li><li><a href="global.html#enumClippedBeltUnderlayType">enumClippedBeltUnderlayType</a></li><li><a href="global.html#enumColorMixingResults">enumColorMixingResults</a></li><li><a href="global.html#enumColors">enumColors</a></li><li><a href="global.html#enumColorsToHexCode">enumColorsToHexCode</a></li><li><a href="global.html#enumColorToShortcode">enumColorToShortcode</a></li><li><a href="global.html#enumCutterVariants">enumCutterVariants</a></li><li><a href="global.html#enumDebugOverlayMode">enumDebugOverlayMode</a></li><li><a href="global.html#enumDebugOverlayModeNext">enumDebugOverlayModeNext</a></li><li><a href="global.html#enumDirection">enumDirection</a></li><li><a href="global.html#enumDirectionToAngle">enumDirectionToAngle</a></li><li><a href="global.html#enumDirectionToVector">enumDirectionToVector</a></li><li><a href="global.html#enumDisplayMode">enumDisplayMode</a></li><li><a href="global.html#enumHubGoalRewards">enumHubGoalRewards</a></li><li><a href="global.html#enumHubGoalRewardsToContentUnlocked">enumHubGoalRewardsToContentUnlocked</a></li><li><a href="global.html#enumInvertedDirections">enumInvertedDirections</a></li><li><a href="global.html#enumItemProcessorRequirements">enumItemProcessorRequirements</a></li><li><a href="global.html#enumItemProcessorTypes">enumItemProcessorTypes</a></li><li><a href="global.html#enumLocalSavegameStatus">enumLocalSavegameStatus</a></li><li><a href="global.html#enumLogicGateType">enumLogicGateType</a></li><li><a href="global.html#enumLogicGateVariants">enumLogicGateVariants</a></li><li><a href="global.html#enumMinerVariants">enumMinerVariants</a></li><li><a href="global.html#enumMouseButton">enumMouseButton</a></li><li><a href="global.html#enumNotificationType">enumNotificationType</a></li><li><a href="global.html#enumPainterVariants">enumPainterVariants</a></li><li><a href="global.html#enumPinSlotType">enumPinSlotType</a></li><li><a href="global.html#enumRotaterVariants">enumRotaterVariants</a></li><li><a href="global.html#enumSavePriority">enumSavePriority</a></li><li><a href="global.html#enumShortcodeToColor">enumShortcodeToColor</a></li><li><a href="global.html#enumShortcodeToSubShape">enumShortcodeToSubShape</a></li><li><a href="global.html#enumSubShape">enumSubShape</a></li><li><a href="global.html#enumSubShapeToShortcode">enumSubShapeToShortcode</a></li><li><a href="global.html#enumTransistorVariants">enumTransistorVariants</a></li><li><a href="global.html#enumTypeToSize">enumTypeToSize</a></li><li><a href="global.html#enumUndergroundBeltMode">enumUndergroundBeltMode</a></li><li><a href="global.html#enumUndergroundBeltVariants">enumUndergroundBeltVariants</a></li><li><a href="global.html#enumUnderlayTypeToClipRect">enumUnderlayTypeToClipRect</a></li><li><a href="global.html#enumVariantToGate">enumVariantToGate</a></li><li><a href="global.html#enumVirtualProcessorVariants">enumVirtualProcessorVariants</a></li><li><a href="global.html#enumWireType">enumWireType</a></li><li><a href="global.html#enumWireVariant">enumWireVariant</a></li><li><a href="global.html#epsilonCompare">epsilonCompare</a></li><li><a href="global.html#extendSchema">extendSchema</a></li><li><a href="global.html#FAKE_BELT_ACCEPTOR_SLOT">FAKE_BELT_ACCEPTOR_SLOT</a></li><li><a href="global.html#FAKE_BELT_EJECTOR_SLOT_BY_DIRECTION">FAKE_BELT_EJECTOR_SLOT_BY_DIRECTION</a></li><li><a href="global.html#fastArrayDelete">fastArrayDelete</a></li><li><a href="global.html#fastArrayDeleteValue">fastArrayDeleteValue</a></li><li><a href="global.html#fastArrayDeleteValueIfContained">fastArrayDeleteValueIfContained</a></li><li><a href="global.html#fillInLinkIntoTranslation">fillInLinkIntoTranslation</a></li><li><a href="global.html#findCode">findCode</a></li><li><a href="global.html#findNiceIntegerValue">findNiceIntegerValue</a></li><li><a href="global.html#findNiceValue">findNiceValue</a></li><li><a href="global.html#formatBigNumber">formatBigNumber</a></li><li><a href="global.html#formatBigNumberFull">formatBigNumberFull</a></li><li><a href="global.html#formatItemsPerSecond">formatItemsPerSecond</a></li><li><a href="global.html#formatSeconds">formatSeconds</a></li><li><a href="global.html#formatSecondsToTimeAgo">formatSecondsToTimeAgo</a></li><li><a href="global.html#freeCanvas">freeCanvas</a></li><li><a href="global.html#freeCanvasBuckets">freeCanvasBuckets</a></li><li><a href="global.html#gBuildingsByCategory">gBuildingsByCategory</a></li><li><a href="global.html#gBuildingVariants">gBuildingVariants</a></li><li><a href="global.html#gComponentRegistry">gComponentRegistry</a></li><li><a href="global.html#generateFileDownload">generateFileDownload</a></li><li><a href="global.html#generateLevelDefinitions">generateLevelDefinitions</a></li><li><a href="global.html#generateMatrixRotations">generateMatrixRotations</a></li><li><a href="global.html#generateUpgrades">generateUpgrades</a></li><li><a href="global.html#getBufferStats">getBufferStats</a></li><li><a href="global.html#getBufferVramUsageBytes">getBufferVramUsageBytes</a></li><li><a href="global.html#getBuildingDataFromCode">getBuildingDataFromCode</a></li><li><a href="global.html#getCodeFromBuildingData">getCodeFromBuildingData</a></li><li><a href="global.html#getDeviceDPI">getDeviceDPI</a></li><li><a href="global.html#getPlatformName">getPlatformName</a></li><li><a href="global.html#getRandomHint">getRandomHint</a></li><li><a href="global.html#getRomanNumber">getRomanNumber</a></li><li><a href="global.html#getSavegameInterface">getSavegameInterface</a></li><li><a href="global.html#getStringForKeyCode">getStringForKeyCode</a></li><li><a href="global.html#gGameSpeedRegistry">gGameSpeedRegistry</a></li><li><a href="global.html#gItemRegistry">gItemRegistry</a></li><li><a href="global.html#GLOBAL_APP">GLOBAL_APP</a></li><li><a href="global.html#indexMapToArray">indexMapToArray</a></li><li><a href="global.html#initBuildingCodesAfterResourcesLoaded">initBuildingCodesAfterResourcesLoaded</a></li><li><a href="global.html#initBuildingsByCategory">initBuildingsByCategory</a></li><li><a href="global.html#internalBuildStringFromArgs">internalBuildStringFromArgs</a></li><li><a href="global.html#ipcRenderer">ipcRenderer</a></li><li><a href="global.html#isAndroid">isAndroid</a></li><li><a href="global.html#isIos">isIos</a></li><li><a href="global.html#isSupportedBrowser">isSupportedBrowser</a></li><li><a href="global.html#isTrueItem">isTrueItem</a></li><li><a href="global.html#isTruthyItem">isTruthyItem</a></li><li><a href="global.html#itemResolverSingleton">itemResolverSingleton</a></li><li><a href="global.html#itemTypes">itemTypes</a></li><li><a href="global.html#LANGUAGES">LANGUAGES</a></li><li><a href="global.html#lastCanvas">lastCanvas</a></li><li><a href="global.html#lastContext">lastContext</a></li><li><a href="global.html#layers">layers</a></li><li><a href="global.html#lerp">lerp</a></li><li><a href="global.html#make2DUndefinedArray">make2DUndefinedArray</a></li><li><a href="global.html#makeButton">makeButton</a></li><li><a href="global.html#makeButtonElement">makeButtonElement</a></li><li><a href="global.html#makeDiv">makeDiv</a></li><li><a href="global.html#makeDivElement">makeDivElement</a></li><li><a href="global.html#makeNewRng">makeNewRng</a></li><li><a href="global.html#makeOffscreenBuffer">makeOffscreenBuffer</a></li><li><a href="global.html#MAX_LABEL_LENGTH">MAX_LABEL_LENGTH</a></li><li><a href="global.html#MAX_QUEUED_CHARGES">MAX_QUEUED_CHARGES</a></li><li><a href="global.html#mixVector">mixVector</a></li><li><a href="global.html#newEmptyMap">newEmptyMap</a></li><li><a href="global.html#ongoingClickDetectors">ongoingClickDetectors</a></li><li><a href="global.html#prepareHighDPIContext">prepareHighDPIContext</a></li><li><a href="global.html#preparePayload">preparePayload</a></li><li><a href="global.html#randomChoice">randomChoice</a></li><li><a href="global.html#randomInt">randomInt</a></li><li><a href="global.html#rebalance">rebalance</a></li><li><a href="global.html#registerBuildingVariant">registerBuildingVariant</a></li><li><a href="global.html#registerCanvas">registerCanvas</a></li><li><a href="global.html#registeredCanvas">registeredCanvas</a></li><li><a href="global.html#removeAllChildren">removeAllChildren</a></li><li><a href="global.html#resizeCanvas">resizeCanvas</a></li><li><a href="global.html#resizeCanvasAndClear">resizeCanvasAndClear</a></li><li><a href="global.html#resizeHighDPICanvas">resizeHighDPICanvas</a></li><li><a href="global.html#rotateDirectionalObject">rotateDirectionalObject</a></li><li><a href="global.html#rotateFlatMatrix3x3">rotateFlatMatrix3x3</a></li><li><a href="global.html#round1Digit">round1Digit</a></li><li><a href="global.html#round1DigitLocalized">round1DigitLocalized</a></li><li><a href="global.html#round2Digits">round2Digits</a></li><li><a href="global.html#round3Digits">round3Digits</a></li><li><a href="global.html#round4Digits">round4Digits</a></li><li><a href="global.html#safeModulo">safeModulo</a></li><li><a href="global.html#savegameInterfaces">savegameInterfaces</a></li><li><a href="global.html#schemaObject">schemaObject</a></li><li><a href="global.html#schemaToJsonSchema">schemaToJsonSchema</a></li><li><a href="global.html#serializeError">serializeError</a></li><li><a href="global.html#serializeEvent">serializeEvent</a></li><li><a href="global.html#serializeSchema">serializeSchema</a></li><li><a href="global.html#setGlobalApp">setGlobalApp</a></li><li><a href="global.html#SHORT_KEY_CACHE">SHORT_KEY_CACHE</a></li><li><a href="global.html#smoothenDpi">smoothenDpi</a></li><li><a href="global.html#smoothPulse">smoothPulse</a></li><li><a href="global.html#startFileChoose">startFileChoose</a></li><li><a href="global.html#statisticsUnitsSeconds">statisticsUnitsSeconds</a></li><li><a href="global.html#stats">stats</a></li><li><a href="global.html#stringifyObjectContainingErrors">stringifyObjectContainingErrors</a></li><li><a href="global.html#typed">typed</a></li><li><a href="global.html#variantsCache">variantsCache</a></li><li><a href="global.html#verifySchema">verifySchema</a></li><li><a href="global.html#waitNextFrame">waitNextFrame</a></li><li><a href="global.html#wireVariants">wireVariants</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Dec 16 2020 10:12:11 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
