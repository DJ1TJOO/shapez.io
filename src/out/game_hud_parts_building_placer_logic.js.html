<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: game/hud/parts/building_placer_logic.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: game/hud/parts/building_placer_logic.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { globalConfig } from "../../../core/config";
import { gMetaBuildingRegistry } from "../../../core/global_registries";
import { Signal, STOP_PROPAGATION } from "../../../core/signal";
import { TrackedState } from "../../../core/tracked_state";
import { Vector } from "../../../core/vector";
import { enumMouseButton } from "../../camera";
import { StaticMapEntityComponent } from "../../components/static_map_entity";
import { Entity } from "../../entity";
import { KEYMAPPINGS } from "../../key_action_mapper";
import { defaultBuildingVariant, MetaBuilding } from "../../meta_building";
import { BaseHUDPart } from "../base_hud_part";
import { SOUNDS } from "../../../platform/sound";
import { MetaMinerBuilding, enumMinerVariants } from "../../buildings/miner";
import { enumHubGoalRewards } from "../../tutorial_goals";
import { getBuildingDataFromCode, getCodeFromBuildingData } from "../../building_codes";
import { MetaHubBuilding } from "../../buildings/hub";

/**
 * Contains all logic for the building placer - this doesn't include the rendering
 * of info boxes or drawing.
 */
export class HUDBuildingPlacerLogic extends BaseHUDPart {
    /**
     * Initializes the logic
     * @see BaseHUDPart.initialize
     */
    initialize() {
        /**
         * We use a fake entity to get information about how a building will look
         * once placed
         * @type {Entity}
         */
        this.fakeEntity = null;

        // Signals
        this.signals = {
            variantChanged: new Signal(),
            draggingStarted: new Signal(),
        };

        /**
         * The current building
         * @type {TypedTrackedState&lt;MetaBuilding?>}
         */
        this.currentMetaBuilding = new TrackedState(this.onSelectedMetaBuildingChanged, this);

        /**
         * The current rotation
         * @type {number}
         */
        this.currentBaseRotationGeneral = 0;

        /**
         * The current rotation preference for each building.
         * @type{Object.&lt;string,number>}
         */
        this.preferredBaseRotations = {};

        /**
         * Whether we are currently dragging
         * @type {boolean}
         */
        this.currentlyDragging = false;

        /**
         * Current building variant
         * @type {TypedTrackedState&lt;string>}
         */
        this.currentVariant = new TrackedState(() => this.signals.variantChanged.dispatch());

        /**
         * Whether we are currently drag-deleting
         * @type {boolean}
         */
        this.currentlyDeleting = false;

        /**
         * Stores which variants for each building we prefer, this is based on what
         * the user last selected
         * @type {Object.&lt;string, string>}
         */
        this.preferredVariants = {};

        /**
         * The tile we last dragged from
         * @type {Vector}
         */
        this.lastDragTile = null;

        /**
         * The side for direction lock
         * @type {number} (0|1)
         */
        this.currentDirectionLockSide = 0;

        /**
         * Whether the side for direction lock has not yet been determined.
         * @type {boolean}
         */
        this.currentDirectionLockSideIndeterminate = true;

        this.initializeBindings();
    }

    /**
     * Initializes all bindings
     */
    initializeBindings() {
        // KEYBINDINGS
        const keyActionMapper = this.root.keyMapper;
        keyActionMapper.getBinding(KEYMAPPINGS.placement.rotateWhilePlacing).add(this.tryRotate, this);
        keyActionMapper.getBinding(KEYMAPPINGS.placement.cycleBuildingVariants).add(this.cycleVariants, this);
        keyActionMapper
            .getBinding(KEYMAPPINGS.placement.switchDirectionLockSide)
            .add(this.switchDirectionLockSide, this);
        keyActionMapper.getBinding(KEYMAPPINGS.general.back).add(this.abortPlacement, this);
        keyActionMapper.getBinding(KEYMAPPINGS.placement.pipette).add(this.startPipette, this);
        this.root.gameState.inputReciever.keyup.add(this.checkForDirectionLockSwitch, this);

        // BINDINGS TO GAME EVENTS
        this.root.hud.signals.buildingsSelectedForCopy.add(this.abortPlacement, this);
        this.root.hud.signals.pasteBlueprintRequested.add(this.abortPlacement, this);
        this.root.signals.storyGoalCompleted.add(() => this.signals.variantChanged.dispatch());
        this.root.signals.storyGoalCompleted.add(() => this.currentMetaBuilding.set(null));
        this.root.signals.upgradePurchased.add(() => this.signals.variantChanged.dispatch());
        this.root.signals.editModeChanged.add(this.onEditModeChanged, this);

        // MOUSE BINDINGS
        this.root.camera.downPreHandler.add(this.onMouseDown, this);
        this.root.camera.movePreHandler.add(this.onMouseMove, this);
        this.root.camera.upPostHandler.add(this.onMouseUp, this);
    }

    /**
     * Called when the edit mode got changed
     * @param {Layer} layer
     */
    onEditModeChanged(layer) {
        const metaBuilding = this.currentMetaBuilding.get();
        if (metaBuilding) {
            if (metaBuilding.getLayer() !== layer) {
                // This layer doesn't fit the edit mode anymore
                this.currentMetaBuilding.set(null);
            }
        }
    }

    /**
     * Returns the current base rotation for the current meta-building.
     * @returns {number}
     */
    get currentBaseRotation() {
        if (!this.root.app.settings.getAllSettings().rotationByBuilding) {
            return this.currentBaseRotationGeneral;
        }
        const metaBuilding = this.currentMetaBuilding.get();
        if (metaBuilding &amp;&amp; this.preferredBaseRotations.hasOwnProperty(metaBuilding.getId())) {
            return this.preferredBaseRotations[metaBuilding.getId()];
        } else {
            return this.currentBaseRotationGeneral;
        }
    }

    /**
     * Sets the base rotation for the current meta-building.
     * @param {number} rotation The new rotation/angle.
     */
    set currentBaseRotation(rotation) {
        if (!this.root.app.settings.getAllSettings().rotationByBuilding) {
            this.currentBaseRotationGeneral = rotation;
        } else {
            const metaBuilding = this.currentMetaBuilding.get();
            if (metaBuilding) {
                this.preferredBaseRotations[metaBuilding.getId()] = rotation;
            } else {
                this.currentBaseRotationGeneral = rotation;
            }
        }
    }

    /**
     * Returns if the direction lock is currently active
     * @returns {boolean}
     */
    get isDirectionLockActive() {
        const metaBuilding = this.currentMetaBuilding.get();
        return (
            metaBuilding &amp;&amp;
            metaBuilding.getHasDirectionLockAvailable() &amp;&amp;
            this.root.keyMapper.getBinding(KEYMAPPINGS.placementModifiers.lockBeltDirection).pressed
        );
    }

    /**
     * Returns the current direction lock corner, that is, the corner between
     * mouse and original start point
     * @returns {Vector|null}
     */
    get currentDirectionLockCorner() {
        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return null;
        }

        if (!this.lastDragTile) {
            // Haven't dragged yet
            return null;
        }

        // Figure which points the line visits
        const worldPos = this.root.camera.screenToWorld(mousePosition);
        const mouseTile = worldPos.toTileSpace();

        // Figure initial direction
        const dx = Math.abs(this.lastDragTile.x - mouseTile.x);
        const dy = Math.abs(this.lastDragTile.y - mouseTile.y);
        if (dx === 0 &amp;&amp; dy === 0) {
            // Back at the start. Try a new direction.
            this.currentDirectionLockSideIndeterminate = true;
        } else if (this.currentDirectionLockSideIndeterminate) {
            this.currentDirectionLockSideIndeterminate = false;
            this.currentDirectionLockSide = dx &lt;= dy ? 0 : 1;
        }

        if (this.currentDirectionLockSide === 0) {
            return new Vector(this.lastDragTile.x, mouseTile.y);
        } else {
            return new Vector(mouseTile.x, this.lastDragTile.y);
        }
    }

    /**
     * Aborts the placement
     */
    abortPlacement() {
        if (this.currentMetaBuilding.get()) {
            this.currentMetaBuilding.set(null);
            return STOP_PROPAGATION;
        }
    }

    /**
     * Aborts any dragging
     */
    abortDragging() {
        this.currentlyDragging = true;
        this.currentlyDeleting = false;
        this.initialPlacementVector = null;
        this.lastDragTile = null;
    }

    /**
     * @see BaseHUDPart.update
     */
    update() {
        // Abort placement if a dialog was shown in the meantime
        if (this.root.hud.hasBlockingOverlayOpen()) {
            this.abortPlacement();
            return;
        }

        // Always update since the camera might have moved
        const mousePos = this.root.app.mousePosition;
        if (mousePos) {
            this.onMouseMove(mousePos);
        }

        // Make sure we have nothing selected while in overview mode
        if (this.root.camera.getIsMapOverlayActive()) {
            if (this.currentMetaBuilding.get()) {
                this.currentMetaBuilding.set(null);
            }
        }
    }

    /**
     * Tries to rotate the current building
     */
    tryRotate() {
        const selectedBuilding = this.currentMetaBuilding.get();
        if (selectedBuilding) {
            if (this.root.keyMapper.getBinding(KEYMAPPINGS.placement.rotateInverseModifier).pressed) {
                this.currentBaseRotation = (this.currentBaseRotation + 270) % 360;
            } else {
                this.currentBaseRotation = (this.currentBaseRotation + 90) % 360;
            }
            const staticComp = this.fakeEntity.components.StaticMapEntity;
            staticComp.rotation = this.currentBaseRotation;
        }
    }

    /**
     * Tries to delete the building under the mouse
     */
    deleteBelowCursor() {
        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return false;
        }

        const worldPos = this.root.camera.screenToWorld(mousePosition);
        const tile = worldPos.toTileSpace();
        const contents = this.root.map.getTileContent(tile, this.root.currentLayer);
        if (contents) {
            if (this.root.logic.tryDeleteBuilding(contents)) {
                this.root.soundProxy.playUi(SOUNDS.destroyBuilding);
                return true;
            }
        }
        return false;
    }

    /**
     * Starts the pipette function
     */
    startPipette() {
        // Disable in overview
        if (this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return;
        }

        const worldPos = this.root.camera.screenToWorld(mousePosition);
        const tile = worldPos.toTileSpace();

        const contents = this.root.map.getTileContent(tile, this.root.currentLayer);
        if (!contents) {
            const tileBelow = this.root.map.getLowerLayerContentXY(tile.x, tile.y);

            // Check if there's a shape or color item below, if so select the miner
            if (
                tileBelow &amp;&amp;
                this.root.app.settings.getAllSettings().pickMinerOnPatch &amp;&amp;
                this.root.currentLayer === "regular"
            ) {
                this.currentMetaBuilding.set(gMetaBuildingRegistry.findByClass(MetaMinerBuilding));

                // Select chained miner if available, since that's always desired once unlocked
                if (this.root.hubGoals.isRewardUnlocked(enumHubGoalRewards.reward_miner_chainable)) {
                    this.currentVariant.set(enumMinerVariants.chainable);
                }
            } else {
                this.currentMetaBuilding.set(null);
            }
            return;
        }

        // Try to extract the building
        const buildingCode = contents.components.StaticMapEntity.code;
        const extracted = getBuildingDataFromCode(buildingCode);

        // Disable pipetting the hub
        if (extracted.metaInstance.getId() === gMetaBuildingRegistry.findByClass(MetaHubBuilding).getId()) {
            this.currentMetaBuilding.set(null);
            return;
        }

        // If the building we are picking is the same as the one we have, clear the cursor.
        if (
            this.currentMetaBuilding.get() &amp;&amp;
            extracted.metaInstance.getId() === this.currentMetaBuilding.get().getId() &amp;&amp;
            extracted.variant === this.currentVariant.get()
        ) {
            this.currentMetaBuilding.set(null);
            return;
        }

        this.currentMetaBuilding.set(extracted.metaInstance);
        this.currentVariant.set(extracted.variant);
        this.currentBaseRotation = contents.components.StaticMapEntity.rotation;
    }

    /**
     * Switches the side for the direction lock manually
     */
    switchDirectionLockSide() {
        this.currentDirectionLockSide = 1 - this.currentDirectionLockSide;
    }

    /**
     * Checks if the direction lock key got released and if such, resets the placement
     * @param {any} args
     */
    checkForDirectionLockSwitch({ keyCode }) {
        if (
            keyCode ===
            this.root.keyMapper.getBinding(KEYMAPPINGS.placementModifiers.lockBeltDirection).keyCode
        ) {
            this.abortDragging();
        }
    }

    /**
     * Tries to place the current building at the given tile
     * @param {Vector} tile
     * @param {object} entity
     * @param {boolean} multipalyerPlace
     */
    tryPlaceCurrentBuildingAt(tile, entity = null, uid = null, multipalyerPlace = false) {
        if (this.root.camera.zoomLevel &lt; globalConfig.mapChunkOverviewMinZoom) {
            // Dont allow placing in overview mode
            return;
        }

        if (entity !== null) this.currentMetaBuilding.set(entity.building);

        const metaBuilding = this.currentMetaBuilding.get();
        const { rotation, rotationVariant } = metaBuilding.computeOptimalDirectionAndRotationVariantAtTile({
            root: this.root,
            tile: new Vector(tile.x, tile.y),
            rotation: this.currentBaseRotation,
            variant: this.currentVariant.get(),
            layer: metaBuilding.getLayer(),
        });

        entity = this.root.logic.tryPlaceBuilding(
            entity !== null ?
            {
                origin: entity.origin,
                originalRotation: entity.originalRotation,
                rotation: entity.rotation,
                rotationVariant: entity.rotationVariant,
                variant: entity.variant,
                building: entity.building,
            } :
            {
                origin: tile,
                rotation,
                rotationVariant,
                originalRotation: this.currentBaseRotation,
                building: this.currentMetaBuilding.get(),
                variant: this.currentVariant.get(),
            },
            uid,
            multipalyerPlace
        );

        if (entity) {
            // Succesfully placed, find which entity we actually placed
            if (!multipalyerPlace) this.root.signals.entityManuallyPlaced.dispatch(entity);

            // Check if we should flip the orientation (used for tunnels)
            if (
                metaBuilding.getFlipOrientationAfterPlacement() &amp;&amp;
                !this.root.keyMapper.getBinding(
                    KEYMAPPINGS.placementModifiers.placementDisableAutoOrientation
                ).pressed
            ) {
                this.currentBaseRotation = (180 + this.currentBaseRotation) % 360;
            }

            // Check if we should stop placement
            if (!metaBuilding.getStayInPlacementMode() &amp;&amp;
                !this.root.keyMapper.getBinding(KEYMAPPINGS.placementModifiers.placeMultiple).pressed &amp;&amp;
                !this.root.app.settings.getAllSettings().alwaysMultiplace
            ) {
                // Stop placement
                this.currentMetaBuilding.set(null);
            }
            return true;
        } else {
            return false;
        }
    }

    /**
     * Cycles through the variants
     */
    cycleVariants() {
        const metaBuilding = this.currentMetaBuilding.get();
        if (!metaBuilding) {
            this.currentVariant.set(defaultBuildingVariant);
        } else {
            const availableVariants = metaBuilding.getAvailableVariants(this.root);
            let index = availableVariants.indexOf(this.currentVariant.get());
            if (index &lt; 0) {
                index = 0;
                console.warn("Invalid variant selected:", this.currentVariant.get());
            }
            const newIndex = (index + 1) % availableVariants.length;
            const newVariant = availableVariants[newIndex];
            this.setVariant(newVariant);
        }
    }

    /**
     * Sets the current variant to the given variant
     * @param {string} variant
     */
    setVariant(variant) {
        const metaBuilding = this.currentMetaBuilding.get();
        this.currentVariant.set(variant);

        this.preferredVariants[metaBuilding.getId()] = variant;
    }

    /**
     * Performs the direction locked placement between two points after
     * releasing the mouse
     */
    executeDirectionLockedPlacement() {
        const metaBuilding = this.currentMetaBuilding.get();
        if (!metaBuilding) {
            // No active building
            return;
        }

        // Get path to place
        const path = this.computeDirectionLockPath();

        // Store if we placed anything
        let anythingPlaced = false;

        // Perform this in bulk to avoid recalculations
        this.root.logic.performBulkOperation(() => {
            for (let i = 0; i &lt; path.length; ++i) {
                const { rotation, tile } = path[i];
                this.currentBaseRotation = rotation;
                if (this.tryPlaceCurrentBuildingAt(tile)) {
                    anythingPlaced = true;
                }
            }
        });

        if (anythingPlaced) {
            this.root.soundProxy.playUi(metaBuilding.getPlacementSound());
        }
    }

    /**
     * Finds the path which the current direction lock will use
     * @returns {Array&lt;{ tile: Vector, rotation: number }>}
     */
    computeDirectionLockPath() {
        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return [];
        }

        let result = [];

        // Figure which points the line visits
        const worldPos = this.root.camera.screenToWorld(mousePosition);
        let endTile = worldPos.toTileSpace();
        let startTile = this.lastDragTile;

        // if the alt key is pressed, reverse belt planner direction by switching start and end tile
        if (this.root.keyMapper.getBinding(KEYMAPPINGS.placementModifiers.placeInverse).pressed) {
            let tmp = startTile;
            startTile = endTile;
            endTile = tmp;
        }

        // Place from start to corner
        const pathToCorner = this.currentDirectionLockCorner.sub(startTile);
        const deltaToCorner = pathToCorner.normalize().round();
        const lengthToCorner = Math.round(pathToCorner.length());
        let currentPos = startTile.copy();

        let rotation = (Math.round(Math.degrees(deltaToCorner.angle()) / 90) * 90 + 360) % 360;

        if (lengthToCorner > 0) {
            for (let i = 0; i &lt; lengthToCorner; ++i) {
                result.push({
                    tile: currentPos.copy(),
                    rotation,
                });
                currentPos.addInplace(deltaToCorner);
            }
        }

        // Place from corner to end
        const pathFromCorner = endTile.sub(this.currentDirectionLockCorner);
        const deltaFromCorner = pathFromCorner.normalize().round();
        const lengthFromCorner = Math.round(pathFromCorner.length());

        if (lengthFromCorner > 0) {
            rotation = (Math.round(Math.degrees(deltaFromCorner.angle()) / 90) * 90 + 360) % 360;
            for (let i = 0; i &lt; lengthFromCorner + 1; ++i) {
                result.push({
                    tile: currentPos.copy(),
                    rotation,
                });
                currentPos.addInplace(deltaFromCorner);
            }
        } else {
            // Finish last one
            result.push({
                tile: currentPos.copy(),
                rotation,
            });
        }
        return result;
    }

    /**
     * Selects a given building
     * @param {MetaBuilding} metaBuilding
     */
    startSelection(metaBuilding) {
        this.currentMetaBuilding.set(metaBuilding);
    }

    /**
     * Called when the selected buildings changed
     * @param {MetaBuilding} metaBuilding
     */
    onSelectedMetaBuildingChanged(metaBuilding) {
        this.abortDragging();
        this.root.hud.signals.selectedPlacementBuildingChanged.dispatch(metaBuilding);
        if (metaBuilding) {
            const availableVariants = metaBuilding.getAvailableVariants(this.root);
            const preferredVariant = this.preferredVariants[metaBuilding.getId()];

            // Choose last stored variant if possible, otherwise the default one
            let variant;
            if (!preferredVariant || !availableVariants.includes(preferredVariant)) {
                variant = availableVariants[0];
            } else {
                variant = preferredVariant;
            }

            this.currentVariant.set(variant);

            this.fakeEntity = new Entity(null);
            metaBuilding.setupEntityComponents(this.fakeEntity, null);

            this.fakeEntity.addComponent(
                new StaticMapEntityComponent({
                    origin: new Vector(0, 0),
                    rotation: 0,
                    tileSize: metaBuilding.getDimensions(this.currentVariant.get()).copy(),
                    code: getCodeFromBuildingData(metaBuilding, variant, 0),
                })
            );
            metaBuilding.updateVariants(this.fakeEntity, 0, this.currentVariant.get());
        } else {
            this.fakeEntity = null;
        }

        // Since it depends on both, rerender twice
        this.signals.variantChanged.dispatch();
    }

    /**
     * mouse down pre handler
     * @param {Vector} pos
     * @param {enumMouseButton} button
     */
    onMouseDown(pos, button) {
        if (this.root.camera.getIsMapOverlayActive()) {
            // We do not allow dragging if the overlay is active
            return;
        }

        const metaBuilding = this.currentMetaBuilding.get();

        // Placement
        if (button === enumMouseButton.left &amp;&amp; metaBuilding) {
            this.currentlyDragging = true;
            this.currentlyDeleting = false;
            this.lastDragTile = this.root.camera.screenToWorld(pos).toTileSpace();

            // Place initial building, but only if direction lock is not active
            if (!this.isDirectionLockActive) {
                if (this.tryPlaceCurrentBuildingAt(this.lastDragTile)) {
                    this.root.soundProxy.playUi(metaBuilding.getPlacementSound());
                }
            }
            return STOP_PROPAGATION;
        }

        // Deletion
        if (
            button === enumMouseButton.right &amp;&amp;
            (!metaBuilding || !this.root.app.settings.getAllSettings().clearCursorOnDeleteWhilePlacing)
        ) {
            this.currentlyDragging = true;
            this.currentlyDeleting = true;
            this.lastDragTile = this.root.camera.screenToWorld(pos).toTileSpace();
            if (this.deleteBelowCursor()) {
                return STOP_PROPAGATION;
            }
        }

        // Cancel placement
        if (button === enumMouseButton.right &amp;&amp; metaBuilding) {
            this.currentMetaBuilding.set(null);
        }
    }

    /**
     * mouse move pre handler
     * @param {Vector} pos
     */
    onMouseMove(pos) {
        if (this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        // Check for direction lock
        if (this.isDirectionLockActive) {
            return;
        }

        const metaBuilding = this.currentMetaBuilding.get();
        if ((metaBuilding || this.currentlyDeleting) &amp;&amp; this.lastDragTile) {
            const oldPos = this.lastDragTile;
            let newPos = this.root.camera.screenToWorld(pos).toTileSpace();

            // Check if camera is moving, since then we do nothing
            if (this.root.camera.desiredCenter) {
                this.lastDragTile = newPos;
                return;
            }

            // Check if anything changed
            if (!oldPos.equals(newPos)) {
                // Automatic Direction
                if (
                    metaBuilding &amp;&amp;
                    metaBuilding.getRotateAutomaticallyWhilePlacing(this.currentVariant.get()) &amp;&amp;
                    !this.root.keyMapper.getBinding(
                        KEYMAPPINGS.placementModifiers.placementDisableAutoOrientation
                    ).pressed
                ) {
                    const delta = newPos.sub(oldPos);
                    const angleDeg = Math.degrees(delta.angle());
                    this.currentBaseRotation = (Math.round(angleDeg / 90) * 90 + 360) % 360;

                    // Holding alt inverts the placement
                    if (this.root.keyMapper.getBinding(KEYMAPPINGS.placementModifiers.placeInverse).pressed) {
                        this.currentBaseRotation = (180 + this.currentBaseRotation) % 360;
                    }
                }

                // bresenham
                let x0 = oldPos.x;
                let y0 = oldPos.y;
                let x1 = newPos.x;
                let y1 = newPos.y;

                var dx = Math.abs(x1 - x0);
                var dy = Math.abs(y1 - y0);
                var sx = x0 &lt; x1 ? 1 : -1;
                var sy = y0 &lt; y1 ? 1 : -1;
                var err = dx - dy;

                let anythingPlaced = false;
                let anythingDeleted = false;

                while (this.currentlyDeleting || this.currentMetaBuilding.get()) {
                    if (this.currentlyDeleting) {
                        // Deletion
                        const contents = this.root.map.getLayerContentXY(x0, y0, this.root.currentLayer);
                        if (contents &amp;&amp; !contents.queuedForDestroy &amp;&amp; !contents.destroyed) {
                            if (this.root.logic.tryDeleteBuilding(contents)) {
                                anythingDeleted = true;
                            }
                        }
                    } else {
                        // Placement
                        if (this.tryPlaceCurrentBuildingAt(new Vector(x0, y0))) {
                            anythingPlaced = true;
                        }
                    }

                    if (x0 === x1 &amp;&amp; y0 === y1) break;
                    var e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x0 += sx;
                    }
                    if (e2 &lt; dx) {
                        err += dx;
                        y0 += sy;
                    }
                }

                if (anythingPlaced) {
                    this.root.soundProxy.playUi(metaBuilding.getPlacementSound());
                }
                if (anythingDeleted) {
                    this.root.soundProxy.playUi(SOUNDS.destroyBuilding);
                }
            }

            this.lastDragTile = newPos;
            return STOP_PROPAGATION;
        }
    }

    /**
     * Mouse up handler
     */
    onMouseUp() {
        if (this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        // Check for direction lock
        if (this.lastDragTile &amp;&amp; this.currentlyDragging &amp;&amp; this.isDirectionLockActive) {
            this.executeDirectionLockedPlacement();
        }

        this.abortDragging();
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AdinplayAdProvider_AdinplayAdProvider.html">AdinplayAdProvider</a></li><li><a href="AdProviderInterface_AdProviderInterface.html">AdProviderInterface</a></li><li><a href="AtlasDefinition_AtlasDefinition.html">AtlasDefinition</a></li><li><a href="AtlasSprite_AtlasSprite.html">AtlasSprite</a></li><li><a href="BackgroundResourcesLoader_BackgroundResourcesLoader.html">BackgroundResourcesLoader</a></li><li><a href="BaseDataType.html">BaseDataType</a></li><li><a href="BaseGameSpeed_BaseGameSpeed.html">BaseGameSpeed</a></li><li><a href="BaseHUDPart_BaseHUDPart.html">BaseHUDPart</a></li><li><a href="BaseItem.html">BaseItem</a></li><li><a href="BaseMap_BaseMap.html">BaseMap</a></li><li><a href="BaseSavegameInterface_BaseSavegameInterface.html">BaseSavegameInterface</a></li><li><a href="BaseSetting_BaseSetting.html">BaseSetting</a></li><li><a href="BasicSerializableObject_BasicSerializableObject.html">BasicSerializableObject</a></li><li><a href="BeltComponent_BeltComponent.html">BeltComponent</a></li><li><a href="BeltPath.html">BeltPath</a></li><li><a href="BeltSystem.html">BeltSystem</a></li><li><a href="Blueprint_Blueprint.html">Blueprint</a></li><li><a href="BooleanItem_BooleanItem.html">BooleanItem</a></li><li><a href="BufferMaintainer_BufferMaintainer.html">BufferMaintainer</a></li><li><a href="ColorItem_ColorItem.html">ColorItem</a></li><li><a href="Component_Component.html">Component</a></li><li><a href="ConstantSignalComponent_ConstantSignalComponent.html">ConstantSignalComponent</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="DialogLoading.html">DialogLoading</a></li><li><a href="DialogWithForm_DialogWithForm.html">DialogWithForm</a></li><li><a href="DynamicDomAttach_DynamicDomAttach.html">DynamicDomAttach</a></li><li><a href="DynamicTickrate_DynamicTickrate.html">DynamicTickrate</a></li><li><a href="Entity_Entity.html">Entity</a></li><li><a href="EntityComponentStorage.html">EntityComponentStorage</a></li><li><a href="FormElementItemChooser_FormElementItemChooser.html">FormElementItemChooser</a></li><li><a href="GameCore.html">GameCore</a></li><li><a href="GamedistributionAdProvider_GamedistributionAdProvider.html">GamedistributionAdProvider</a></li><li><a href="GameHUD_GameHUD.html">GameHUD</a></li><li><a href="GameLoadingOverlay_GameLoadingOverlay.html">GameLoadingOverlay</a></li><li><a href="GameLogic_GameLogic.html">GameLogic</a></li><li><a href="GameRoot.html">GameRoot</a></li><li><a href="GameState.html">GameState</a></li><li><a href="GameSystem.html">GameSystem</a></li><li><a href="GameSystemManager_GameSystemManager.html">GameSystemManager</a></li><li><a href="GameSystemWithFilter_GameSystemWithFilter.html">GameSystemWithFilter</a></li><li><a href="GameTime_GameTime.html">GameTime</a></li><li><a href="HubGoals_HubGoals.html">HubGoals</a></li><li><a href="HUDBaseToolbar_HUDBaseToolbar.html">HUDBaseToolbar</a></li><li><a href="HUDBuildingPlacerLogic.html">HUDBuildingPlacerLogic</a></li><li><a href="HUDEntityDebugger.html">HUDEntityDebugger</a></li><li><a href="HUDLayerPreview.html">HUDLayerPreview</a></li><li><a href="HUDPinnedShapes.html">HUDPinnedShapes</a></li><li><a href="HUDShapeStatisticsHandle.html">HUDShapeStatisticsHandle</a></li><li><a href="HUDTutorialVideoOffer.html">HUDTutorialVideoOffer</a></li><li><a href="InputDistributor_InputDistributor.html">InputDistributor</a></li><li><a href="KeyActionMapper_KeyActionMapper.html">KeyActionMapper</a></li><li><a href="Keybinding_Keybinding.html">Keybinding</a></li><li><a href="LeverComponent_LeverComponent.html">LeverComponent</a></li><li><a href="Logger.html">Logger</a></li><li><a href="LogicGateComponent_LogicGateComponent.html">LogicGateComponent</a></li><li><a href="MapChunk_MapChunk.html">MapChunk</a></li><li><a href="MapChunkView_MapChunkView.html">MapChunkView</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MetaBuilding_MetaBuilding.html">MetaBuilding</a></li><li><a href="ProductionAnalytics_ProductionAnalytics.html">ProductionAnalytics</a></li><li><a href="RandomNumberGenerator_RandomNumberGenerator.html">RandomNumberGenerator</a></li><li><a href="RestrictionManager_RestrictionManager.html">RestrictionManager</a></li><li><a href="SavegameSerializer.html">SavegameSerializer</a></li><li><a href="ShapeDefinition_ShapeDefinition.html">ShapeDefinition</a></li><li><a href="ShapeDefinitionManager_ShapeDefinitionManager.html">ShapeDefinitionManager</a></li><li><a href="ShapeItem_ShapeItem.html">ShapeItem</a></li><li><a href="SoundProxy_SoundProxy.html">SoundProxy</a></li><li><a href="SpriteAtlasLink.html">SpriteAtlasLink</a></li><li><a href="StaleAreaDetector_StaleAreaDetector.html">StaleAreaDetector</a></li><li><a href="StateManager.html">StateManager</a></li><li><a href="StaticMapEntityComponent_StaticMapEntityComponent.html">StaticMapEntityComponent</a></li><li><a href="StorageComponent_StorageComponent.html">StorageComponent</a></li><li><a href="TextualGameState.html">TextualGameState</a></li><li><a href="TrailerMaker_TrailerMaker.html">TrailerMaker</a></li><li><a href="TypeArray_TypeArray.html">TypeArray</a></li><li><a href="TypeClass_TypeClass.html">TypeClass</a></li><li><a href="TypeClassData_TypeClassData.html">TypeClassData</a></li><li><a href="TypeClassFromMetaclass_TypeClassFromMetaclass.html">TypeClassFromMetaclass</a></li><li><a href="TypeClassId_TypeClassId.html">TypeClassId</a></li><li><a href="TypeEnum_TypeEnum.html">TypeEnum</a></li><li><a href="TypeFixedClass_TypeFixedClass.html">TypeFixedClass</a></li><li><a href="TypeKeyValueMap_TypeKeyValueMap.html">TypeKeyValueMap</a></li><li><a href="TypeMetaClass_TypeMetaClass.html">TypeMetaClass</a></li><li><a href="TypeNullable_TypeNullable.html">TypeNullable</a></li><li><a href="TypePair_TypePair.html">TypePair</a></li><li><a href="TypeStructuredObject_TypeStructuredObject.html">TypeStructuredObject</a></li><li><a href="UndergroundBeltComponent_UndergroundBeltComponent.html">UndergroundBeltComponent</a></li><li><a href="Vector_Vector.html">Vector</a></li><li><a href="WireComponent_WireComponent.html">WireComponent</a></li><li><a href="WrappedSoundInstance.html">WrappedSoundInstance</a></li></ul><h3>Global</h3><ul><li><a href="global.html#accessNestedPropertyReverse">accessNestedPropertyReverse</a></li><li><a href="global.html#allApplicationSettings">allApplicationSettings</a></li><li><a href="global.html#arrayAllDirections">arrayAllDirections</a></li><li><a href="global.html#arrayDelete">arrayDelete</a></li><li><a href="global.html#arrayDeleteValue">arrayDeleteValue</a></li><li><a href="global.html#arrayUndergroundRotationVariantToMode">arrayUndergroundRotationVariantToMode</a></li><li><a href="global.html#atlasFiles">atlasFiles</a></li><li><a href="global.html#autoDetectLanguageId">autoDetectLanguageId</a></li><li><a href="global.html#buildBuildingCodeCache">buildBuildingCodeCache</a></li><li><a href="global.html#cachebust">cachebust</a></li><li><a href="global.html#capitalizeFirstLetter">capitalizeFirstLetter</a></li><li><a href="global.html#catchErrors">catchErrors</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clearBufferBacklog">clearBufferBacklog</a></li><li><a href="global.html#COLOR_ITEM_SINGLETONS">COLOR_ITEM_SINGLETONS</a></li><li><a href="global.html#compressInt">compressInt</a></li><li><a href="global.html#compressObject">compressObject</a></li><li><a href="global.html#compressObjectInternal">compressObjectInternal</a></li><li><a href="global.html#compressU8WHeader">compressU8WHeader</a></li><li><a href="global.html#computeCrc">computeCrc</a></li><li><a href="global.html#createSimpleShape">createSimpleShape</a></li><li><a href="global.html#decompressInt">decompressInt</a></li><li><a href="global.html#decompressObject">decompressObject</a></li><li><a href="global.html#decompressObjectInternal">decompressObjectInternal</a></li><li><a href="global.html#decompressU8WHeader">decompressU8WHeader</a></li><li><a href="global.html#deserializeSchema">deserializeSchema</a></li><li><a href="global.html#disableImageSmoothing">disableImageSmoothing</a></li><li><a href="global.html#drawRotatedSprite">drawRotatedSprite</a></li><li><a href="global.html#drawSpriteClipped">drawSpriteClipped</a></li><li><a href="global.html#enableImageSmoothing">enableImageSmoothing</a></li><li><a href="global.html#enumAnalyticsDataSource">enumAnalyticsDataSource</a></li><li><a href="global.html#enumAngleToDirection">enumAngleToDirection</a></li><li><a href="global.html#enumBalancerVariants">enumBalancerVariants</a></li><li><a href="global.html#enumCategories">enumCategories</a></li><li><a href="global.html#enumClippedBeltUnderlayType">enumClippedBeltUnderlayType</a></li><li><a href="global.html#enumColorMixingResults">enumColorMixingResults</a></li><li><a href="global.html#enumColors">enumColors</a></li><li><a href="global.html#enumColorsToHexCode">enumColorsToHexCode</a></li><li><a href="global.html#enumColorToShortcode">enumColorToShortcode</a></li><li><a href="global.html#enumCutterVariants">enumCutterVariants</a></li><li><a href="global.html#enumDebugOverlayMode">enumDebugOverlayMode</a></li><li><a href="global.html#enumDebugOverlayModeNext">enumDebugOverlayModeNext</a></li><li><a href="global.html#enumDirection">enumDirection</a></li><li><a href="global.html#enumDirectionToAngle">enumDirectionToAngle</a></li><li><a href="global.html#enumDirectionToVector">enumDirectionToVector</a></li><li><a href="global.html#enumDisplayMode">enumDisplayMode</a></li><li><a href="global.html#enumHubGoalRewards">enumHubGoalRewards</a></li><li><a href="global.html#enumHubGoalRewardsToContentUnlocked">enumHubGoalRewardsToContentUnlocked</a></li><li><a href="global.html#enumInvertedDirections">enumInvertedDirections</a></li><li><a href="global.html#enumItemProcessorRequirements">enumItemProcessorRequirements</a></li><li><a href="global.html#enumItemProcessorTypes">enumItemProcessorTypes</a></li><li><a href="global.html#enumLocalSavegameStatus">enumLocalSavegameStatus</a></li><li><a href="global.html#enumLogicGateType">enumLogicGateType</a></li><li><a href="global.html#enumLogicGateVariants">enumLogicGateVariants</a></li><li><a href="global.html#enumMinerVariants">enumMinerVariants</a></li><li><a href="global.html#enumMouseButton">enumMouseButton</a></li><li><a href="global.html#enumNotificationType">enumNotificationType</a></li><li><a href="global.html#enumPainterVariants">enumPainterVariants</a></li><li><a href="global.html#enumPinSlotType">enumPinSlotType</a></li><li><a href="global.html#enumRotaterVariants">enumRotaterVariants</a></li><li><a href="global.html#enumSavePriority">enumSavePriority</a></li><li><a href="global.html#enumShortcodeToColor">enumShortcodeToColor</a></li><li><a href="global.html#enumShortcodeToSubShape">enumShortcodeToSubShape</a></li><li><a href="global.html#enumSubShape">enumSubShape</a></li><li><a href="global.html#enumSubShapeToShortcode">enumSubShapeToShortcode</a></li><li><a href="global.html#enumTransistorVariants">enumTransistorVariants</a></li><li><a href="global.html#enumTypeToSize">enumTypeToSize</a></li><li><a href="global.html#enumUndergroundBeltMode">enumUndergroundBeltMode</a></li><li><a href="global.html#enumUndergroundBeltVariants">enumUndergroundBeltVariants</a></li><li><a href="global.html#enumUnderlayTypeToClipRect">enumUnderlayTypeToClipRect</a></li><li><a href="global.html#enumVariantToGate">enumVariantToGate</a></li><li><a href="global.html#enumVirtualProcessorVariants">enumVirtualProcessorVariants</a></li><li><a href="global.html#enumWireType">enumWireType</a></li><li><a href="global.html#enumWireVariant">enumWireVariant</a></li><li><a href="global.html#epsilonCompare">epsilonCompare</a></li><li><a href="global.html#extendSchema">extendSchema</a></li><li><a href="global.html#FAKE_BELT_ACCEPTOR_SLOT">FAKE_BELT_ACCEPTOR_SLOT</a></li><li><a href="global.html#FAKE_BELT_EJECTOR_SLOT_BY_DIRECTION">FAKE_BELT_EJECTOR_SLOT_BY_DIRECTION</a></li><li><a href="global.html#fastArrayDelete">fastArrayDelete</a></li><li><a href="global.html#fastArrayDeleteValue">fastArrayDeleteValue</a></li><li><a href="global.html#fastArrayDeleteValueIfContained">fastArrayDeleteValueIfContained</a></li><li><a href="global.html#fillInLinkIntoTranslation">fillInLinkIntoTranslation</a></li><li><a href="global.html#findCode">findCode</a></li><li><a href="global.html#findNiceIntegerValue">findNiceIntegerValue</a></li><li><a href="global.html#findNiceValue">findNiceValue</a></li><li><a href="global.html#formatBigNumber">formatBigNumber</a></li><li><a href="global.html#formatBigNumberFull">formatBigNumberFull</a></li><li><a href="global.html#formatItemsPerSecond">formatItemsPerSecond</a></li><li><a href="global.html#formatSeconds">formatSeconds</a></li><li><a href="global.html#formatSecondsToTimeAgo">formatSecondsToTimeAgo</a></li><li><a href="global.html#freeCanvas">freeCanvas</a></li><li><a href="global.html#freeCanvasBuckets">freeCanvasBuckets</a></li><li><a href="global.html#gBuildingsByCategory">gBuildingsByCategory</a></li><li><a href="global.html#gBuildingVariants">gBuildingVariants</a></li><li><a href="global.html#gComponentRegistry">gComponentRegistry</a></li><li><a href="global.html#generateFileDownload">generateFileDownload</a></li><li><a href="global.html#generateLevelDefinitions">generateLevelDefinitions</a></li><li><a href="global.html#generateMatrixRotations">generateMatrixRotations</a></li><li><a href="global.html#generateUpgrades">generateUpgrades</a></li><li><a href="global.html#getBufferStats">getBufferStats</a></li><li><a href="global.html#getBufferVramUsageBytes">getBufferVramUsageBytes</a></li><li><a href="global.html#getBuildingDataFromCode">getBuildingDataFromCode</a></li><li><a href="global.html#getCodeFromBuildingData">getCodeFromBuildingData</a></li><li><a href="global.html#getDeviceDPI">getDeviceDPI</a></li><li><a href="global.html#getPlatformName">getPlatformName</a></li><li><a href="global.html#getRandomHint">getRandomHint</a></li><li><a href="global.html#getRomanNumber">getRomanNumber</a></li><li><a href="global.html#getSavegameInterface">getSavegameInterface</a></li><li><a href="global.html#getStringForKeyCode">getStringForKeyCode</a></li><li><a href="global.html#gGameSpeedRegistry">gGameSpeedRegistry</a></li><li><a href="global.html#gItemRegistry">gItemRegistry</a></li><li><a href="global.html#GLOBAL_APP">GLOBAL_APP</a></li><li><a href="global.html#indexMapToArray">indexMapToArray</a></li><li><a href="global.html#initBuildingCodesAfterResourcesLoaded">initBuildingCodesAfterResourcesLoaded</a></li><li><a href="global.html#initBuildingsByCategory">initBuildingsByCategory</a></li><li><a href="global.html#internalBuildStringFromArgs">internalBuildStringFromArgs</a></li><li><a href="global.html#ipcRenderer">ipcRenderer</a></li><li><a href="global.html#isAndroid">isAndroid</a></li><li><a href="global.html#isIos">isIos</a></li><li><a href="global.html#isSupportedBrowser">isSupportedBrowser</a></li><li><a href="global.html#isTrueItem">isTrueItem</a></li><li><a href="global.html#isTruthyItem">isTruthyItem</a></li><li><a href="global.html#itemResolverSingleton">itemResolverSingleton</a></li><li><a href="global.html#itemTypes">itemTypes</a></li><li><a href="global.html#LANGUAGES">LANGUAGES</a></li><li><a href="global.html#lastCanvas">lastCanvas</a></li><li><a href="global.html#lastContext">lastContext</a></li><li><a href="global.html#layers">layers</a></li><li><a href="global.html#lerp">lerp</a></li><li><a href="global.html#make2DUndefinedArray">make2DUndefinedArray</a></li><li><a href="global.html#makeButton">makeButton</a></li><li><a href="global.html#makeButtonElement">makeButtonElement</a></li><li><a href="global.html#makeDiv">makeDiv</a></li><li><a href="global.html#makeDivElement">makeDivElement</a></li><li><a href="global.html#makeNewRng">makeNewRng</a></li><li><a href="global.html#makeOffscreenBuffer">makeOffscreenBuffer</a></li><li><a href="global.html#MAX_LABEL_LENGTH">MAX_LABEL_LENGTH</a></li><li><a href="global.html#MAX_QUEUED_CHARGES">MAX_QUEUED_CHARGES</a></li><li><a href="global.html#mixVector">mixVector</a></li><li><a href="global.html#newEmptyMap">newEmptyMap</a></li><li><a href="global.html#ongoingClickDetectors">ongoingClickDetectors</a></li><li><a href="global.html#prepareHighDPIContext">prepareHighDPIContext</a></li><li><a href="global.html#preparePayload">preparePayload</a></li><li><a href="global.html#randomChoice">randomChoice</a></li><li><a href="global.html#randomInt">randomInt</a></li><li><a href="global.html#rebalance">rebalance</a></li><li><a href="global.html#registerBuildingVariant">registerBuildingVariant</a></li><li><a href="global.html#registerCanvas">registerCanvas</a></li><li><a href="global.html#registeredCanvas">registeredCanvas</a></li><li><a href="global.html#removeAllChildren">removeAllChildren</a></li><li><a href="global.html#resizeCanvas">resizeCanvas</a></li><li><a href="global.html#resizeCanvasAndClear">resizeCanvasAndClear</a></li><li><a href="global.html#resizeHighDPICanvas">resizeHighDPICanvas</a></li><li><a href="global.html#rotateDirectionalObject">rotateDirectionalObject</a></li><li><a href="global.html#rotateFlatMatrix3x3">rotateFlatMatrix3x3</a></li><li><a href="global.html#round1Digit">round1Digit</a></li><li><a href="global.html#round1DigitLocalized">round1DigitLocalized</a></li><li><a href="global.html#round2Digits">round2Digits</a></li><li><a href="global.html#round3Digits">round3Digits</a></li><li><a href="global.html#round4Digits">round4Digits</a></li><li><a href="global.html#safeModulo">safeModulo</a></li><li><a href="global.html#savegameInterfaces">savegameInterfaces</a></li><li><a href="global.html#schemaObject">schemaObject</a></li><li><a href="global.html#schemaToJsonSchema">schemaToJsonSchema</a></li><li><a href="global.html#serializeError">serializeError</a></li><li><a href="global.html#serializeEvent">serializeEvent</a></li><li><a href="global.html#serializeSchema">serializeSchema</a></li><li><a href="global.html#setGlobalApp">setGlobalApp</a></li><li><a href="global.html#SHORT_KEY_CACHE">SHORT_KEY_CACHE</a></li><li><a href="global.html#smoothenDpi">smoothenDpi</a></li><li><a href="global.html#smoothPulse">smoothPulse</a></li><li><a href="global.html#startFileChoose">startFileChoose</a></li><li><a href="global.html#statisticsUnitsSeconds">statisticsUnitsSeconds</a></li><li><a href="global.html#stats">stats</a></li><li><a href="global.html#stringifyObjectContainingErrors">stringifyObjectContainingErrors</a></li><li><a href="global.html#typed">typed</a></li><li><a href="global.html#variantsCache">variantsCache</a></li><li><a href="global.html#verifySchema">verifySchema</a></li><li><a href="global.html#waitNextFrame">waitNextFrame</a></li><li><a href="global.html#wireVariants">wireVariants</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Dec 16 2020 10:12:12 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
